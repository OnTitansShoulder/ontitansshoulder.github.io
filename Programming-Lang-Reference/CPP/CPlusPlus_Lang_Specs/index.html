<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="We are all standing on the shoulders of the giants..."><meta name=author content="Zhongkai Liu"><link rel="shortcut icon" href=../../../assets/favicon.ico><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.2.6"><title>C++ Language Reference - Ontitansshoulder</title><link rel=stylesheet href=../../../assets/stylesheets/main.cb6bc1d0.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.39b8e14a.min.css><meta name=theme-color content=#4051b5><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style><link rel=stylesheet href=../../../css/extra.css></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#overview class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=../../.. title=Ontitansshoulder class="md-header-nav__button md-logo" aria-label=Ontitansshoulder> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <div class=md-header-nav__topic> <span class=md-ellipsis> Ontitansshoulder </span> </div> <div class=md-header-nav__topic> <span class=md-ellipsis> C++ Language Reference </span> </div> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class="md-tabs__link md-tabs__link--active"> Notes </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=Ontitansshoulder class="md-nav__button md-logo" aria-label=Ontitansshoulder> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> Ontitansshoulder </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1 checked> <label class=md-nav__link for=nav-1> Notes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Notes data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Notes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> Welcome </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-2 type=checkbox id=nav-1-2> <label class=md-nav__link for=nav-1-2> Foundamentals <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Foundamentals data-md-level=2> <label class=md-nav__title for=nav-1-2> <span class="md-nav__icon md-icon"></span> Foundamentals </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Foundamental/Data_Structures_and_Algos/ class=md-nav__link> Data Structures and Algos </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-3 type=checkbox id=nav-1-3> <label class=md-nav__link for=nav-1-3> Linux <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Linux data-md-level=2> <label class=md-nav__title for=nav-1-3> <span class="md-nav__icon md-icon"></span> Linux </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-3-1 type=checkbox id=nav-1-3-1> <label class=md-nav__link for=nav-1-3-1> Concepts <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Concepts data-md-level=3> <label class=md-nav__title for=nav-1-3-1> <span class="md-nav__icon md-icon"></span> Concepts </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Linux/Concepts/Linux_Foundation/ class=md-nav__link> Linux Foundation </a> </li> <li class=md-nav__item> <a href=../../../Linux/Concepts/Linux_Foundation_System_Admin/ class=md-nav__link> Linux System Administration </a> </li> <li class=md-nav__item> <a href=../../../Linux/Concepts/Linux_Foundation_Network_Admin/ class=md-nav__link> Linux Network Administration </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-3-2 type=checkbox id=nav-1-3-2> <label class=md-nav__link for=nav-1-3-2> Practical References <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Practical References" data-md-level=3> <label class=md-nav__title for=nav-1-3-2> <span class="md-nav__icon md-icon"></span> Practical References </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Linux/Commands/Freq-Used-Shell-Cmds/ class=md-nav__link> Freq Used Shell Cmds </a> </li> <li class=md-nav__item> <a href=../../../Linux/Commands/Networking-Shell-Cmds/ class=md-nav__link> Freq Used Network Cmds </a> </li> <li class=md-nav__item> <a href=../../../Linux/Commands/Text-Manipulating-Cmds/ class=md-nav__link> Text Manipulating Cmds </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-3-3 type=checkbox id=nav-1-3-3> <label class=md-nav__link for=nav-1-3-3> Tricks <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Tricks data-md-level=3> <label class=md-nav__title for=nav-1-3-3> <span class="md-nav__icon md-icon"></span> Tricks </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Linux/References/Freq-Tasks/ class=md-nav__link> Freq Linux Tasks </a> </li> <li class=md-nav__item> <a href=../../../Linux/References/Terminal-Tricks/ class=md-nav__link> Linux Terminal Tricks </a> </li> <li class=md-nav__item> <a href=../../../Linux/References/Vim-Tricks/ class=md-nav__link> Vim Tricks </a> </li> <li class=md-nav__item> <a href=../../../Linux/References/Account-Administration/ class=md-nav__link> Manage Accounts & Groups </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-4 type=checkbox id=nav-1-4> <label class=md-nav__link for=nav-1-4> Cloud <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Cloud data-md-level=2> <label class=md-nav__title for=nav-1-4> <span class="md-nav__icon md-icon"></span> Cloud </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Cloud-and-Containers/Architecture/Cloud-App-Architecture/ class=md-nav__link> Cloud App Architecture </a> </li> <li class=md-nav__item> <a href=../../../Cloud-and-Containers/Docker/Docker/ class=md-nav__link> Docker and Containers </a> </li> <li class=md-nav__item> <a href=../../../Cloud-and-Containers/Docker/Docker-Practical/ class=md-nav__link> Docker Practical </a> </li> <li class=md-nav__item> <a href=../../../Cloud-and-Containers/k8s/K8s-Knowledge/ class=md-nav__link> K8s Knowledge </a> </li> <li class=md-nav__item> <a href=../../../Cloud-and-Containers/k8s/service_mesh/ class=md-nav__link> Service Mesh </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-5 type=checkbox id=nav-1-5> <label class=md-nav__link for=nav-1-5> Monitoring <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Monitoring data-md-level=2> <label class=md-nav__title for=nav-1-5> <span class="md-nav__icon md-icon"></span> Monitoring </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-5-1 type=checkbox id=nav-1-5-1> <label class=md-nav__link for=nav-1-5-1> Splunk <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Splunk data-md-level=3> <label class=md-nav__title for=nav-1-5-1> <span class="md-nav__icon md-icon"></span> Splunk </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Dev-Tools-Reference/Splunk/Splunk-References/ class=md-nav__link> Splunk Knowledge </a> </li> <li class=md-nav__item> <a href=../../../Dev-Tools-Reference/Splunk/Splunk-Dashboarding/ class=md-nav__link> Splunk Dashboarding </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6 type=checkbox id=nav-1-6 checked> <label class=md-nav__link for=nav-1-6> Programming Langs <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Programming Langs" data-md-level=2> <label class=md-nav__title for=nav-1-6> <span class="md-nav__icon md-icon"></span> Programming Langs </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6-1 type=checkbox id=nav-1-6-1> <label class=md-nav__link for=nav-1-6-1> Golang <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Golang data-md-level=3> <label class=md-nav__title for=nav-1-6-1> <span class="md-nav__icon md-icon"></span> Golang </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Golang/Golang-Specs/ class=md-nav__link> Golang Language Reference </a> </li> <li class=md-nav__item> <a href=../../Golang/Best-Practices/ class=md-nav__link> Effective Go </a> </li> <li class=md-nav__item> <a href=../../Golang/Freq-Used-Libs/ class=md-nav__link> Go libraries and examples </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6-2 type=checkbox id=nav-1-6-2> <label class=md-nav__link for=nav-1-6-2> Java <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Java data-md-level=3> <label class=md-nav__title for=nav-1-6-2> <span class="md-nav__icon md-icon"></span> Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Java/Style-Guide/ class=md-nav__link> Style Guide </a> </li> <li class=md-nav__item> <a href=../../Java/Best-Practices/ class=md-nav__link> Effective Java </a> </li> <li class=md-nav__item> <a href=../../Java/Design-Patterns/ class=md-nav__link> Java Design Patterns </a> </li> <li class=md-nav__item> <a href=../../Java/Testing-Design-Patterns/ class=md-nav__link> Testing Design Patterns </a> </li> <li class=md-nav__item> <a href=../../Java/Java_Std_Lib_Cheatsheet/ class=md-nav__link> Java Std Lib Cheatsheet </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6-3 type=checkbox id=nav-1-6-3 checked> <label class=md-nav__link for=nav-1-6-3> C++ <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=C++ data-md-level=3> <label class=md-nav__title for=nav-1-6-3> <span class="md-nav__icon md-icon"></span> C++ </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> C++ Language Reference <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> C++ Language Reference </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#overview class=md-nav__link> Overview </a> </li> <li class=md-nav__item> <a href=#basics class=md-nav__link> Basics </a> <nav class=md-nav aria-label=Basics> <ul class=md-nav__list> <li class=md-nav__item> <a href=#compiler class=md-nav__link> Compiler </a> <nav class=md-nav aria-label=Compiler> <ul class=md-nav__list> <li class=md-nav__item> <a href=#preprocessor class=md-nav__link> Preprocessor </a> </li> <li class=md-nav__item> <a href=#compilation class=md-nav__link> Compilation </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#documenting-and-comments class=md-nav__link> Documenting and Comments </a> </li> <li class=md-nav__item> <a href=#program-entry class=md-nav__link> Program entry </a> </li> <li class=md-nav__item> <a href=#data-and-variables class=md-nav__link> Data and Variables </a> <nav class=md-nav aria-label="Data and Variables"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#declaration-initialization class=md-nav__link> Declaration, Initialization </a> </li> <li class=md-nav__item> <a href=#naming class=md-nav__link> Naming </a> </li> <li class=md-nav__item> <a href=#data-types class=md-nav__link> Data types </a> </li> <li class=md-nav__item> <a href=#casting-and-types class=md-nav__link> Casting and types </a> </li> <li class=md-nav__item> <a href=#strings class=md-nav__link> strings </a> </li> <li class=md-nav__item> <a href=#operators class=md-nav__link> Operators </a> </li> <li class=md-nav__item> <a href=#variable-scopes class=md-nav__link> Variable scopes </a> </li> <li class=md-nav__item> <a href=#arrays class=md-nav__link> Arrays </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#functions class=md-nav__link> Functions </a> <nav class=md-nav aria-label=Functions> <ul class=md-nav__list> <li class=md-nav__item> <a href=#overloading class=md-nav__link> Overloading </a> </li> <li class=md-nav__item> <a href=#templating class=md-nav__link> Templating </a> </li> <li class=md-nav__item> <a href=#inline class=md-nav__link> Inline </a> </li> <li class=md-nav__item> <a href=#namespacing class=md-nav__link> Namespacing </a> </li> <li class=md-nav__item> <a href=#ellipsis class=md-nav__link> Ellipsis </a> </li> <li class=md-nav__item> <a href=#lambda class=md-nav__link> Lambda </a> </li> <li class=md-nav__item> <a href=#function-pointers class=md-nav__link> Function pointers </a> </li> <li class=md-nav__item> <a href=#global-variables class=md-nav__link> Global variables </a> </li> <li class=md-nav__item> <a href=#static-local-variable class=md-nav__link> static local variable </a> </li> <li class=md-nav__item> <a href=#header-files class=md-nav__link> Header files </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#conditionals class=md-nav__link> Conditionals </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#reference-types class=md-nav__link> Reference types </a> <nav class=md-nav aria-label="Reference types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#lvalue-and-rvalue class=md-nav__link> lvalue and rvalue </a> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> References </a> </li> <li class=md-nav__item> <a href=#pointers class=md-nav__link> Pointers </a> </li> <li class=md-nav__item> <a href=#return-references class=md-nav__link> Return references </a> </li> <li class=md-nav__item> <a href=#memory-allocation class=md-nav__link> Memory allocation </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#program-defined-types class=md-nav__link> Program-defined types </a> <nav class=md-nav aria-label="Program-defined types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#enumerations class=md-nav__link> Enumerations </a> </li> <li class=md-nav__item> <a href=#structs class=md-nav__link> Structs </a> </li> <li class=md-nav__item> <a href=#classes class=md-nav__link> Classes </a> <nav class=md-nav aria-label=Classes> <ul class=md-nav__list> <li class=md-nav__item> <a href=#class-templates class=md-nav__link> Class templates </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#std-libraries class=md-nav__link> STD Libraries </a> <nav class=md-nav aria-label="STD Libraries"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#algorithm class=md-nav__link> &lt;algorithm&gt; </a> </li> <li class=md-nav__item> <a href=#iostream class=md-nav__link> &lt;iostream&gt; </a> </li> <li class=md-nav__item> <a href=#iterator class=md-nav__link> &lt;iterator&gt; </a> </li> <li class=md-nav__item> <a href=#random class=md-nav__link> &lt;random&gt; </a> </li> <li class=md-nav__item> <a href=#utility class=md-nav__link> &lt;utility&gt; </a> </li> <li class=md-nav__item> <a href=#cassert class=md-nav__link> &lt;cassert&gt; </a> </li> <li class=md-nav__item> <a href=#cstdint class=md-nav__link> &lt;cstdint&gt; </a> </li> <li class=md-nav__item> <a href=#cstdlib class=md-nav__link> &lt;cstdlib&gt; </a> </li> <li class=md-nav__item> <a href=#cmath class=md-nav__link> &lt;cmath&gt; </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6-4 type=checkbox id=nav-1-6-4> <label class=md-nav__link for=nav-1-6-4> Perl <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Perl data-md-level=3> <label class=md-nav__title for=nav-1-6-4> <span class="md-nav__icon md-icon"></span> Perl </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Perl/Perl-Lang-Specs/ class=md-nav__link> Perl Language Reference </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-6-5 type=checkbox id=nav-1-6-5> <label class=md-nav__link for=nav-1-6-5> Shell <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Shell data-md-level=3> <label class=md-nav__title for=nav-1-6-5> <span class="md-nav__icon md-icon"></span> Shell </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Shell/Shell-Scripting/ class=md-nav__link> Shell Scripting </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../Github-Markdown/ class=md-nav__link> Github Markdown Guide </a> </li> <li class=md-nav__item> <a href=../../Regex-Specs/ class=md-nav__link> Regex Cheatsheet </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-7 type=checkbox id=nav-1-7> <label class=md-nav__link for=nav-1-7> Reading Notes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Reading Notes" data-md-level=2> <label class=md-nav__title for=nav-1-7> <span class="md-nav__icon md-icon"></span> Reading Notes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../Reading-Notes/How-Netflix-Works/ class=md-nav__link> How Netflix Works </a> </li> <li class=md-nav__item> <a href=../../../Reading-Notes/System-Design-Concepts/ class=md-nav__link> System Design Guide </a> </li> <li class=md-nav__item> <a href=../../../Reading-Notes/Why-Latency-Matters/ class=md-nav__link> Why Latency Matters </a> </li> <li class=md-nav__item> <a href=../../../Reading-Notes/DevOps_SRE/ class=md-nav__link> Intro to DevOps and SRE </a> </li> <li class=md-nav__item> <a href=../../../Reading-Notes/Leading-without-formal-authority/ class=md-nav__link> Leading Without Formal Authority </a> </li> <li class=md-nav__item> <a href=../../../Reading-Notes/Google-SRE-Book/ class=md-nav__link> Google SRE Book </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../Good-Reads/ class=md-nav__link> Good Reads </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#overview class=md-nav__link> Overview </a> </li> <li class=md-nav__item> <a href=#basics class=md-nav__link> Basics </a> <nav class=md-nav aria-label=Basics> <ul class=md-nav__list> <li class=md-nav__item> <a href=#compiler class=md-nav__link> Compiler </a> <nav class=md-nav aria-label=Compiler> <ul class=md-nav__list> <li class=md-nav__item> <a href=#preprocessor class=md-nav__link> Preprocessor </a> </li> <li class=md-nav__item> <a href=#compilation class=md-nav__link> Compilation </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#documenting-and-comments class=md-nav__link> Documenting and Comments </a> </li> <li class=md-nav__item> <a href=#program-entry class=md-nav__link> Program entry </a> </li> <li class=md-nav__item> <a href=#data-and-variables class=md-nav__link> Data and Variables </a> <nav class=md-nav aria-label="Data and Variables"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#declaration-initialization class=md-nav__link> Declaration, Initialization </a> </li> <li class=md-nav__item> <a href=#naming class=md-nav__link> Naming </a> </li> <li class=md-nav__item> <a href=#data-types class=md-nav__link> Data types </a> </li> <li class=md-nav__item> <a href=#casting-and-types class=md-nav__link> Casting and types </a> </li> <li class=md-nav__item> <a href=#strings class=md-nav__link> strings </a> </li> <li class=md-nav__item> <a href=#operators class=md-nav__link> Operators </a> </li> <li class=md-nav__item> <a href=#variable-scopes class=md-nav__link> Variable scopes </a> </li> <li class=md-nav__item> <a href=#arrays class=md-nav__link> Arrays </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#functions class=md-nav__link> Functions </a> <nav class=md-nav aria-label=Functions> <ul class=md-nav__list> <li class=md-nav__item> <a href=#overloading class=md-nav__link> Overloading </a> </li> <li class=md-nav__item> <a href=#templating class=md-nav__link> Templating </a> </li> <li class=md-nav__item> <a href=#inline class=md-nav__link> Inline </a> </li> <li class=md-nav__item> <a href=#namespacing class=md-nav__link> Namespacing </a> </li> <li class=md-nav__item> <a href=#ellipsis class=md-nav__link> Ellipsis </a> </li> <li class=md-nav__item> <a href=#lambda class=md-nav__link> Lambda </a> </li> <li class=md-nav__item> <a href=#function-pointers class=md-nav__link> Function pointers </a> </li> <li class=md-nav__item> <a href=#global-variables class=md-nav__link> Global variables </a> </li> <li class=md-nav__item> <a href=#static-local-variable class=md-nav__link> static local variable </a> </li> <li class=md-nav__item> <a href=#header-files class=md-nav__link> Header files </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#conditionals class=md-nav__link> Conditionals </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#reference-types class=md-nav__link> Reference types </a> <nav class=md-nav aria-label="Reference types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#lvalue-and-rvalue class=md-nav__link> lvalue and rvalue </a> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> References </a> </li> <li class=md-nav__item> <a href=#pointers class=md-nav__link> Pointers </a> </li> <li class=md-nav__item> <a href=#return-references class=md-nav__link> Return references </a> </li> <li class=md-nav__item> <a href=#memory-allocation class=md-nav__link> Memory allocation </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#program-defined-types class=md-nav__link> Program-defined types </a> <nav class=md-nav aria-label="Program-defined types"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#enumerations class=md-nav__link> Enumerations </a> </li> <li class=md-nav__item> <a href=#structs class=md-nav__link> Structs </a> </li> <li class=md-nav__item> <a href=#classes class=md-nav__link> Classes </a> <nav class=md-nav aria-label=Classes> <ul class=md-nav__list> <li class=md-nav__item> <a href=#class-templates class=md-nav__link> Class templates </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#std-libraries class=md-nav__link> STD Libraries </a> <nav class=md-nav aria-label="STD Libraries"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#algorithm class=md-nav__link> &lt;algorithm&gt; </a> </li> <li class=md-nav__item> <a href=#iostream class=md-nav__link> &lt;iostream&gt; </a> </li> <li class=md-nav__item> <a href=#iterator class=md-nav__link> &lt;iterator&gt; </a> </li> <li class=md-nav__item> <a href=#random class=md-nav__link> &lt;random&gt; </a> </li> <li class=md-nav__item> <a href=#utility class=md-nav__link> &lt;utility&gt; </a> </li> <li class=md-nav__item> <a href=#cassert class=md-nav__link> &lt;cassert&gt; </a> </li> <li class=md-nav__item> <a href=#cstdint class=md-nav__link> &lt;cstdint&gt; </a> </li> <li class=md-nav__item> <a href=#cstdlib class=md-nav__link> &lt;cstdlib&gt; </a> </li> <li class=md-nav__item> <a href=#cmath class=md-nav__link> &lt;cmath&gt; </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1>C++ Language Reference</h1> <p>This set of notes is taken from <a href=https://www.learncpp.com/ target=_balnk>learncpp.com</a>.</p> <p>C++ language references:</p> <ul> <li><a href=https://cplusplus.com/reference/ target=_blank>cplusplus.com</a></li> <li><a href=https://en.cppreference.com/w/ target=_blank>cppreference.com</a></li> </ul> <p>Continue reading: https://www.learncpp.com/cpp-tutorial/stdvector-capacity-and-stack-behavior/</p> <h2 id=overview>Overview<a class=headerlink href=#overview title="Permanent link">&para;</a></h2> <p>C++ is one of the popular high level languages and requires compiling source code into machine code for computer to run. C++ excels in situations where high performance and precise control over memory and other resources is needed. Some common places where C++ shines:</p> <ul> <li>Video games</li> <li>Real-time systems, i.e. transportation, manufacturing</li> <li>Financial applications, i.e. stock exchange</li> <li>Graphical applications, simulations</li> <li>Productivity applications</li> <li>Embedded systems</li> <li>Audio and video processing</li> <li>AI and neural networks</li> </ul> <p>C++ is designed to allow the programmer a high degree of freedom to do what they want, which is both wonderful and dangerous.</p> <h2 id=basics>Basics<a class=headerlink href=#basics title="Permanent link">&para;</a></h2> <h3 id=compiler>Compiler<a class=headerlink href=#compiler title="Permanent link">&para;</a></h3> <h4 id=preprocessor>Preprocessor<a class=headerlink href=#preprocessor title="Permanent link">&para;</a></h4> <p>Prior to compilation, the code file goes through a phase known as translation. This phase involves the interpretation of <strong>preprocessor</strong>, which can be throught of as a separate program that manipulates the text in each code file.</p> <p>Preprocessor <strong>directives</strong> are instructions that start with a <code>#</code> symbol and end with a <em>newline</em> (no semicolon). Directives tell the preprocessor to perform specific particular text manipulation tasks on normal code text (non-directive lines).</p> <p>Directives are only valid from the point of definition to the end of the file in which they are defined.</p> <p><code>#include</code> is one type of directive, which tells preprocessor to replace it with the contents of the included file, which gets preprocessed as well recursively.</p> <p>Avoid using relative paths in <code>#include</code> directives. Instead, pass in <code>-I</code> option to specify alternate directory to look for source files. In this way, changing directory structure do not require updating the include paths.</p> <p>The <code>#define</code> directive can be used to create a <strong>macro</strong>, a rule that defines how <em>input text</em> is converted into replacement <em>output text</em>. Two basic types of macros: object-like macros, and function-like macros.</p> <p>Object-like macros are traditionally typed in all capital letters, using underscores to represent spaces. They used to be used as a cheaper alternative to constant variables and is considered a <em>legacy</em> feature.</p> <p>A speical use case for Object-like macro with no substitution text is to remove occurrance of certain text, or serve as a marker for <code>#ifdef</code>.</p> <p><code>#ifdef, #ifndef, and #endif</code> allows the preprocessor to check whether an identifier has been previously <code>#defined</code>, and skip redefining it if that is the case. This is known as the <strong>header guard</strong>.</p> <div class=highlight><pre><span></span><code><span class=cp>#ifndef HEADERFILENAME_H</span>
<span class=cp>#define HEADERFILENAME_H</span>
<span class=c1>// declarations</span>
<span class=cp>#endif</span>
</code></pre></div> <p><code>#pragma once</code> serves as an alternate form of header guards but only supported by modern compilers, not old compilers.</p> <p>In this way, when this header file is being included by multiple files that end up being merged together, they won't cause repeated declarations error.</p> <p><code>#if 0, #endif</code> is commonly used to exclude a block of code from being compiled (as if they are commented out).</p> <h4 id=compilation>Compilation<a class=headerlink href=#compilation title="Permanent link">&para;</a></h4> <p>During compilation, C++ compiler sequentially goes through each source code (<code>.h .c .cpp</code>) file in your program and does two things:</p> <ul> <li>check the syntax correctness</li> <li>translate code into machine language and create the object file (<code>.o .obj</code>)</li> </ul> <p>After the object files are created, the linker comes in:</p> <ul> <li>resolve dependencies</li> <li>merge object files into a single executable program</li> <li>pull in library files referenced, which are collections of precompiled and prepackaged code for reuse</li> </ul> <p>Compile code with <code>g++ &lt;source_files&gt; -o &lt;output_program&gt;</code>. The output program can be run directly with <code>./&lt;output_program&gt;</code>.</p> <p>C++ has evolved and has many language standards. Pass in compiler flags during compilation to change the language standard. i.e. <code>g++ &lt;language_standard_flag&gt; &lt;source_files&gt; -o &lt;output_program&gt;</code>, where language_standard_flag can be <code>-std=c++1/c++14/c++17/c++2a</code></p> <h3 id=documenting-and-comments>Documenting and Comments<a class=headerlink href=#documenting-and-comments title="Permanent link">&para;</a></h3> <p>Single-line comment with <code>//</code>, multi-line comment with <code>/* */</code></p> <p>Indent with 4 spaces. Put the opening curly brace on the same line as the statement. Lines should keep a 80-char maximum and wrap to new line at appropriate place.</p> <h3 id=program-entry>Program entry<a class=headerlink href=#program-entry title="Permanent link">&para;</a></h3> <p>Every C++ program must have a main function or it will fail to link.</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// main function body</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>The main function must have int return type, which will be the exit code. An exit code of 0 typically signals the program execution was successful.</p> <p>To make the program take command line arguments, write the main function this way:</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
    <span class=c1>// main function body</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>argc</code> is the count of arguments passed to the program and is &gt;= 1, since the first argument is always the absolute path to the program. <code>argv</code> is an array of C-style strings and holds the command line arguments.</p> <h3 id=data-and-variables>Data and Variables<a class=headerlink href=#data-and-variables title="Permanent link">&para;</a></h3> <h4 id=declaration-initialization>Declaration, Initialization<a class=headerlink href=#declaration-initialization title="Permanent link">&para;</a></h4> <p>Variable declaration can be one line each or multiple variables of the same type declared in one line:</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// declared but uninitialized</span>
<span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>;</span> <span class=c1>// declare multiple vars in one line</span>
<span class=kt>double</span> <span class=n>d</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// inline copy constant initialize</span>
<span class=kt>int</span> <span class=nf>e</span><span class=p>(</span> <span class=mi>5</span> <span class=p>);</span> <span class=c1>// inline initialize</span>
<span class=kt>int</span> <span class=n>f</span><span class=p>{</span> <span class=mi>10</span> <span class=p>};</span> <span class=c1>// inline brace initialize (preferred)</span>
<span class=kt>int</span> <span class=n>g</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>100</span> <span class=p>};</span> <span class=c1>// inline copy brace initialize</span>
<span class=kt>int</span> <span class=n>h</span><span class=p>{};</span> <span class=c1>// inline value initialize to 0, aka zero initialization (default is 0 for int)</span>
</code></pre></div> <p>Some rules of thumb:</p> <ul> <li>initialize your variables upon creation, using one of the inline methods mentioned above</li> <li>initialize one variable on each line</li> <li>prefer inline brace initialize since in some circumstances it reports error when wrong variable type is being assigned, i.e. double assigned to int</li> <li>prefer value initialization when the variable value will be replaced later before use</li> </ul> <h4 id=naming>Naming<a class=headerlink href=#naming title="Permanent link">&para;</a></h4> <p><a href=https://www.learncpp.com/cpp-tutorial/keywords-and-naming-identifiers/ target=_blank>Reserved keywords</a> must not be used as variable identifiers.</p> <p>Some naming rules of thumb for variables and function names:</p> <ul> <li>compose of letters, numbers, and underscore</li> <li>begin with a lower case letter</li> <li>use underscore to separate whole words, or use camelCase. Be consistent throught the program</li> </ul> <h4 id=data-types>Data types<a class=headerlink href=#data-types title="Permanent link">&para;</a></h4> <p><strong>Foundamental</strong> data types:</p> <ul> <li>Boolean: <code>bool</code></li> <li>Character: <code>char, wchar_t, char8_t (C++20), char16_t (C++11), char32_t (C++11)</code></li> <li>Integer: <code>short, int, long, long long (C++11)</code></li> <li>Floating Point: <code>float, double, long double</code></li> <li>Null Pointer: <code>std::nullptr_t (C++11)</code></li> <li>Void: <code>void</code></li> </ul> <p>Booleans are represented internally as integers. When printing you will get 1 and 0. To get true and false, set <code>std::cout &lt;&lt; std::boolalpha;</code>, and similarly for stdin <code>std::cin &gt;&gt; std::boolalpha;</code>.</p> <p>Integers are signed by default. To declare unsigned integers, prefix variable type with <code>unsigned</code> keyword. i.e. <code>unsigned int num;</code> However, you should favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.</p> <p>Use <code>std::setprecision(&lt;int&gt;)</code> to set the precision of floating numbers (default is 6). Although be careful changing this, since higher precision may introduce rounding errors.</p> <p>The <code>_t</code> suffix means type.</p> <p>The <code>sizeof</code> operator is a unary operator that takes either a type or a variable, and returns its size in bytes (of type <code>std::size_t</code>). The integer types have unguaranteed size on different hardware. There is only a guaranteed minimal size. i.e. an int can be 2 bytes in old architecture but 4 bytes on modern architecture.</p> <p><strong>Fixed-width integers</strong> are introduced by including the <code>&lt;cstdint&gt;</code> header to solve the issue of unguaranteed integer sizes on different hardware. They can be declared as:</p> <div class=highlight><pre><span></span><code><span class=n>std</span><span class=o>::</span><span class=kt>int8_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>int16_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>int32_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>int64_t</span>
<span class=c1>// unsigned</span>
<span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>uint16_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>uint32_t</span>
<span class=n>std</span><span class=o>::</span><span class=kt>uint64_t</span>
</code></pre></div> <p>Still, fixed-width integers are not guaranteed to be defined on all architectures. And for some modern architecture, using fixed-width integer might slow down the problem, as the CPU has to do extra work to process the smaller variables. For those cases, consider using <strong>fast and least integers</strong>.</p> <p>Some ruls of thumb:</p> <ul> <li>prefer <code>int</code> when integer size doesn't matter</li> <li>prefer <code>std::int#_t</code> when storing a quantity that needs a guaranteed range</li> <li>prefer <code>std::uint#_t</code> when doing bit manipulation or when some overflow/wrap-around behavior is desired.</li> <li>avoid using unsigned types for quantities</li> <li>avoid 8-bit fixed-width integer types which often get treated as chars</li> <li>avoid fast and least fixed-width types</li> <li>avoid compiler-specific fixed-width integers, such as VC++ <code>__int8</code></li> </ul> <p><strong>Literal constants</strong> are fixed values explicitly specified. Examples:</p> <div class=highlight><pre><span></span><code><span class=mi>5</span> <span class=c1>// int literal</span>
<span class=mi>5u</span> <span class=c1>// unsigned int literal</span>
<span class=mf>30L</span> <span class=c1>// long literal</span>
<span class=mo>0214</span> <span class=c1>// octal literal</span>
<span class=mh>0xF</span> <span class=c1>// hexadecimal literal</span>
<span class=mb>0b1001&#39;1110</span> <span class=c1>// binary literal, with &#39; as digit separator</span>
<span class=mf>3.0</span> <span class=c1>// double literal</span>
<span class=mf>5.0f</span> <span class=c1>// float literal</span>
<span class=s>&quot;Helloworld&quot;</span> <span class=c1>// C-style string literal</span>
</code></pre></div> <p>C++ will concatenate sequential string literals. The library <code>&lt;bitset&gt;</code> allows printing binary numbers. i.e. <code>std::bitset&lt;8&gt; bin{ 0b1100'0100 };</code></p> <p><strong>Constant variables</strong>, aka symbolic constants, can be created using the <code>const</code> keyword, where the variable value can be determined in compile-time or runtime. Use <code>constexpr</code> to enforce compile-time constant evaluation.</p> <p>Compound types:</p> <ul> <li>Functions</li> <li>Arrays</li> <li>Pointers, to object or to function</li> <li>Reference, L-value reference or R-value reference</li> <li>Enums, scoped or unscoped</li> <li>Classes, Structs, Unions</li> </ul> <h4 id=casting-and-types>Casting and types<a class=headerlink href=#casting-and-types title="Permanent link">&para;</a></h4> <p>A <strong>numeric promotion</strong> is the conversion of smaller numeric types to larger numeric type.</p> <p>Use <strong>explicit type conversion</strong> to explicitly tell the compiler to convert a value from one type to another type.</p> <p>The C-style casts is done via the <code>(&lt;new_type&gt;) variable</code> operator or with the function-like cast <code>&lt;new_type&gt;(variable)</code>. Avoid C-style casts since it risks misuse and not producing expected behavior.</p> <p>There is also static cast using <code>static_cast&lt;new_type&gt;(&lt;expression&gt;)</code> which allows carry out type conversions that may loss precision or cause overflow if done with implicit (automatic) type conversion.</p> <p><code>static_cast</code> is best used to convert one fundamental type into another.</p> <p>The <code>using</code> or <code>typedef</code> keyword can be used to create <strong>type aliases</strong>, which creates an alias for an existing data type. Use a "_t" or "_type" suffix to help decrease the chance of naming collisions with other identifiers. i.e. </p> <div class=highlight><pre><span></span><code><span class=k>using</span> <span class=n>distance_t</span> <span class=o>=</span> <span class=kt>double</span><span class=p>;</span> <span class=c1>// define distance_t as an alias for type double</span>
<span class=k>typedef</span> <span class=kt>double</span> <span class=n>distance_t</span><span class=p>;</span> <span class=c1>// also does the same thing, but discouraged</span>
</code></pre></div> <p>Use type aliases for platform independent coding. Because <code>char, short, int, and long</code> give no indication of their size, it is fairly common for cross-platform programs to use type aliases to define aliases that include the type's size in bits.</p> <p>Also use type aliases to make complex types simple, or help with code documentation and comprehension. i.e. <code>using pairlist_t = std::vector&lt;std::pair&lt;std::string, int&gt;&gt;;</code></p> <p><strong>Type deduction</strong>, aka type inference, is a feature that allows the compiler to deduce the type of an object from the object's non-empty <strong>initializer</strong> through the <code>auto</code> keyword.</p> <p>Type deduction can save a lot of typing and typos in some cases, and is generally safe to use for objects, and improves code readability.</p> <p><code>auto</code> can also be used on function return type to let compiler infer return type from return statements. Favor explicit return types over function return type deduction.</p> <p>However, you can use the tailing return type syntax with the <code>auto</code> return type to make function names line up and improve code readability. i.e. in forward-declarations:</p> <div class=highlight><pre><span></span><code><span class=k>auto</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>;</span>
<span class=k>auto</span> <span class=nf>divide</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>double</span><span class=p>;</span>
<span class=k>auto</span> <span class=nf>printSomething</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kt>void</span><span class=p>;</span>
</code></pre></div> <p><a href=https://anteru.net/blog/2007/c-background-static-reinterpret-and-c-style-casts/ target=_blank>Read more about casting</a></p> <h4 id=strings>strings<a class=headerlink href=#strings title="Permanent link">&para;</a></h4> <p>string type is not a fundamental type, but a compound type. strings are double quoted characters. Quoted text separated by nothing but whitespace (spaces, tabs, or newlines) will be concatenated.</p> <p><code>#include</code> the <code>&lt;string&gt;</code> header to bring in the declarations for <strong>std::string</strong>.</p> <p>A string's length is optained with <code>str.length()</code> function call.</p> <p>The plain quote-surrounded strings are in fact <strong>C-style strings</strong>, not std::string. To specify different types of strings:</p> <p>C-style string is essentially an array of chars which implicitly adds a null character <code>\0</code> to end of the string. The <code>strlen()</code> function from <code>cstring&gt;</code> returns the length of the C-style string without the null terminator.</p> <p>Other useful C-style functions:</p> <ul> <li>strcpy() -- copy a string to another string</li> <li>strcpy_s() strlcpy() -- string copy allowing a size parameter</li> <li>strcat() -- appends one string to another (dangerous)</li> <li>strncat() -- appends one string to another (with buffer length check)</li> <li>strcmp() -- compare two strings (returns 0 if equal)</li> <li>strncmp() -- compare two strings up to a specific number of characters (returns 0 if equal)</li> </ul> <p>As a rule of thumb, use std::string or std::string_view (next lesson) instead of C-style strings. Prefer std::string_view over std::string for read-only strings</p> <p>C++17 introduces <strong>std::string_view</strong> which provides a view of a string to avoid unnecessary copies of strings. It also contains functions for shrinking the view of the string which do not reflect on the underlying string.</p> <div class=highlight><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;string_view&gt;</span><span class=cp></span>

<span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>s1</span> <span class=p>{</span> <span class=s>&quot;Hello, world&quot;</span> <span class=p>};</span> <span class=c1>// c-style string of type const char*</span>
    <span class=k>auto</span> <span class=n>s2</span> <span class=p>{</span> <span class=s>&quot;Hello&quot;</span><span class=n>s</span> <span class=p>};</span> <span class=c1>// std::string</span>
    <span class=k>auto</span> <span class=n>s3</span> <span class=p>{</span> <span class=s>&quot;hi&quot;</span><span class=n>sv</span> <span class=p>};</span> <span class=c1>// std::string_view</span>
    <span class=k>auto</span> <span class=n>s4</span> <span class=p>{</span> <span class=n>s1</span> <span class=p>};</span> <span class=c1>// std::string</span>
    <span class=k>auto</span> <span class=n>s5</span> <span class=p>{</span> <span class=n>s4</span> <span class=p>};</span> <span class=c1>// std::string_view</span>
    <span class=k>auto</span> <span class=n>s6</span> <span class=p>{</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s5</span><span class=p>)</span> <span class=p>};</span> <span class=c1>// std::string</span>
    <span class=k>auto</span> <span class=n>s7</span> <span class=p>{</span> <span class=n>s6</span><span class=p>.</span><span class=n>c_str</span><span class=p>()</span> <span class=p>};</span> <span class=c1>// c-style string</span>
<span class=p>}</span>
</code></pre></div> <p>Prefer passing strings using std::string_view (by value) instead of const std::string&amp;, unless your function calls other functions that require C-style strings or std::string parameters.</p> <h4 id=operators>Operators<a class=headerlink href=#operators title="Permanent link">&para;</a></h4> <ul> <li>Arithematical: <code>+ - * / % ++ --</code></li> <li>Bitwise: <code>&amp; | ^ ~ &lt;&lt; &gt;&gt;</code></li> <li>Logical: <code>== != &lt; &gt; &lt;= &gt;= &amp;&amp; ||</code></li> <li>sizeof: <code>sizeof (&lt;type_or_variable&gt;)</code></li> <li>Type casting: <code>(&lt;type&gt;) &lt;variable&gt;</code></li> </ul> <p><a href=https://www.cplusplus.com/doc/tutorial/operators/ target=_blank>Precedence of operators</a></p> <h4 id=variable-scopes>Variable scopes<a class=headerlink href=#variable-scopes title="Permanent link">&para;</a></h4> <p>Variables declared within a function scope is local variable and only visible within the closure of the function.</p> <h4 id=arrays>Arrays<a class=headerlink href=#arrays title="Permanent link">&para;</a></h4> <p>An <strong>array</strong> is an aggregate data type that holds many values of the same type through a single identifier.</p> <p>A <strong>fixed array</strong> is an array where the length is known at compile time. i.e. <code>int prime[5]{};</code> or <code>int array[]{ 0, 1, 2, 3, 4 };</code></p> <p>Copying large arrays can be very expensive, C++ does not copy an array when an array is passed into a function.</p> <p>A fixed array identifier <strong>decay</strong> (inplicitly convert) to a pointer that points to the first element of the array. This makes <code>void printSize(int array[]);</code> and <code>void printSize(int* array);</code> declarations identical. In most cases, because the pointer doesn't know how large the array is, you'll need to pass in the array size as a separate parameter anyway.</p> <p>Favor the pointer syntax (*) over the array syntax ([]) for array function parameters.</p> <p>When using arrays, ensure that your indices are valid for the range of your array, as compiler does not check this. Array size can be accessed with <code>std::size(&lt;array&gt;)</code>.</p> <p>C++ multi-dimensional array can be declared as <code>int array[3][5]{};</code>.</p> <p>Array indexing:</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
     <span class=kt>int</span> <span class=n>array</span><span class=p>[]{</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span> <span class=p>};</span>
     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>&amp;</span><span class=n>array</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// print memory address of array element 1</span>
     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>array</span><span class=o>+</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// print memory address of array pointer + 1</span>
     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>array</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// prints 7</span>
     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=p>(</span><span class=n>array</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// prints 7</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><strong><code>std::array</code></strong> from <code>&lt;array&gt;</code> works like fixed arrays and makes array management easier. It does auto clean up after going out of scope, and offers convenient functions like <code>size()</code>. i.e. <code>std::array&lt;int, 3&gt; myArray;</code> creates an integer array of size 3.</p> <p>std::array allows assigning values to the array using an initializer list. Access std::array values with the subscript operator <code>[]</code> or the <code>at()</code> function.</p> <p>Always pass std::array by reference or const reference to avoid unnecessary copies. Favor std::array over built-in fixed arrays for any non-trivial array use.</p> <p>A <strong>dynamic array</strong> allows choosing an array length at runtime. Use <code>new[] and delete[]</code> with dynamic arrays. i.e. <code>int* array{ new int[length]{} };</code> and <code>delete[] array;</code>.</p> <p>Dynamic arrays can be initialized using initializer lists, and benefits from <code>auto</code> type deduction. i.e. <code>auto* array{ new int[5]{ 9, 7, 5, 3, 1 } };</code></p> <p>Note that for-each loop do not work with pointer arrays since the array size is unknown.</p> <p>A pointer to a pointer can be used to create dynamical multi-dimensional arrays. i.e.</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=kt>int</span><span class=o>**</span> <span class=n>array2d</span> <span class=p>{</span> <span class=k>new</span> <span class=kt>int</span><span class=o>*</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=p>};</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>array2d</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=n>array2d</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>3</span><span class=p>];</span> <span class=c1>// access</span>

    <span class=c1>// free up</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>delete</span><span class=p>[]</span> <span class=n>array2d</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=k>delete</span><span class=p>[]</span> <span class=n>array2d</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><strong><code>std::vector</code></strong> from <code>&lt;vector&gt;</code> makes working with dynamic arrays safer and easier. It does auto clean up after going out of scope, and offers convenient functions like <code>size(), resize()</code>. i.e. <code>std::vector&lt;int&gt; empty {};</code></p> <p>std::vector allows assigning values to the array using an initializer list. Access std::vector values with the subscript operator <code>[]</code> or the <code>at()</code> function.</p> <p>An <strong>iterator</strong> is an object designed to traverse through a container (array, string) and provide access to each element along the way.</p> <p>The simplest kind of iterator is a <strong>pointer</strong>, which works for data stored <strong>sequentially</strong> in memory.</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>array</span> <span class=n>a</span><span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span> <span class=p>};</span>
    <span class=k>auto</span> <span class=n>begin</span><span class=p>{</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>};</span> <span class=c1>// or { a.data() }, { a.begin() }, { std::begin(a) }</span>
    <span class=k>auto</span> <span class=n>end</span><span class=p>{</span> <span class=n>begin</span> <span class=o>+</span> <span class=n>std</span><span class=o>::</span><span class=n>size</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=p>};</span> <span class=c1>// or { a.end() }, { std::end(a) }</span>
    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>ptr</span><span class=p>{</span> <span class=n>begin</span> <span class=p>};</span> <span class=n>ptr</span> <span class=o>!=</span> <span class=n>end</span><span class=p>;</span> <span class=o>++</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=functions>Functions<a class=headerlink href=#functions title="Permanent link">&para;</a></h3> <p>A function must be either declared or defined before it is being used.</p> <p>Offically, a <strong>forward declaration</strong> allows us to tell the compiler about the existence of an identifier before actually defining the identifier. This is when <strong>header files</strong> come into play.</p> <div class=highlight><pre><span></span><code><span class=n>return_type</span> <span class=nf>function_name</span><span class=p>(</span><span class=n>arg_type</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg_type</span> <span class=n>arg2</span><span class=p>,</span> <span class=p>...);</span> <span class=c1>// forward declaration; the var names are optional but good to keep as it is self-documenting</span>

<span class=n>return_type</span> <span class=nf>function_name</span><span class=p>(</span><span class=n>arg_type</span> <span class=n>arg1</span><span class=p>,</span> <span class=n>arg_type</span> <span class=n>arg2</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
    <span class=c1>// function body</span>
<span class=p>}</span>
</code></pre></div> <p>A <strong>default argument</strong> is a default value provided for a function parameter. When making a function call, the caller can optionally provide an argument for any function parameter that has a default argument.</p> <p>Default arguments can only be provided for the rightmost unspecified parameters, and can be declared in either the forward declaration or the function definition, but not both (best to do it in forward declaration).</p> <h4 id=overloading>Overloading<a class=headerlink href=#overloading title="Permanent link">&para;</a></h4> <p><strong>Function overloading</strong> allows us to create multiple functions with the same name, so long as each identically named function has different <strong>parameters</strong> (including ellipsis parameters i.e. <code>void foo(int x, ...);</code>), or function-level qualifiers (const, volatile, ref-qualifiers).</p> <h4 id=templating>Templating<a class=headerlink href=#templating title="Permanent link">&para;</a></h4> <p><strong>Template</strong> system was designed to simplify the process of creating functions (or classes) that are able to work with different data types.</p> <p>A <strong>placeholder</strong> type represents some type that is not known at the time the template is written, but that will be provided later. Use a single capital letter (starting with T) to name the placeholder type.</p> <p>A <strong>function template</strong> is a function-like definition that is used to generate overloaded functions, each with a different set of actual types. i.e.</p> <div class=highlight><pre><span></span><code><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=c1>// template parameter declaration</span>
<span class=n>T</span> <span class=n>max</span><span class=p>(</span><span class=n>T</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// function template definition</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;</span> <span class=n>y</span><span class=p>)</span> <span class=o>?</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>
<span class=p>}</span>
<span class=kt>int</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>max</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// instantiates and calls function max&lt;int&gt;(int, int)</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>max</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// compiler deduced type from arguments</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>max</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// compiler deduced type from arguments</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Favor the normal function call syntax over template argument deduction when using function templates.</p> <h4 id=inline>Inline<a class=headerlink href=#inline title="Permanent link">&para;</a></h4> <p><strong>Inline expansion</strong> is a process where a function call is replaced by the code from the called functions definition. Modern optimizing compilers are typically very good at determining which functions should be made inline to improve final executable performance.</p> <p>A function that is eligible to have its function calls expanded is called an <strong>inline function</strong>. Functions that are always expanded inline:</p> <ul> <li>defined inside a class, struct, or union.</li> <li>constexpr functions</li> </ul> <h4 id=namespacing>Namespacing<a class=headerlink href=#namespacing title="Permanent link">&para;</a></h4> <p>C++ does not allow the same identifier to be defined within the same build context, aka <strong>naming collision</strong>. This can be happening more commonly when a program uses many libraries.</p> <p>A <strong>namespace</strong> is a region that allows you to declare names inside of it for the purpose of disambiguation. Any name declared inside the namespace won't be mistaken for identical names in other scopes.</p> <p><code>std</code> is itself a namespace. <code>::</code> is called the scope resolution operator.</p> <p>Any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined <strong>global namespace</strong>.</p> <p>You can define a namespace by enclosing the identifiers within a namespace block:</p> <div class=highlight><pre><span></span><code><span class=k>namespace</span> <span class=o>&lt;</span><span class=n>namespace_name</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=c1>// namespace body</span>
<span class=p>}</span>
</code></pre></div> <p>The same namespace can be created anywhere, as long as the identifiers within all namespaces of a kind do not clash. namespaces can also be <strong>nested</strong>, by enclosing one in another.</p> <p>One way to access identifiers inside a namespace is to use a <code>using</code> <strong>directive statement</strong>:</p> <div class=highlight><pre><span></span><code><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span> <span class=c1>// at top of program after includes</span>

<span class=kt>void</span> <span class=nf>some_function</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Hello&quot;</span><span class=p>;</span> <span class=c1>// directly access functions without namespace prefix</span>
<span class=p>}</span>
</code></pre></div> <p>However, <code>using namespace</code> should be generally avoided since it increases the risk of causing naming collisions, especially for <code>std</code> namespace.</p> <p>You can also create <strong>namespace aliases</strong> and switch to a different namespace for everywhere it is referenced. Like so:</p> <div class=highlight><pre><span></span><code><span class=k>namespace</span> <span class=n>active</span> <span class=o>=</span> <span class=n>foo</span><span class=p>;</span>

<span class=n>std</span><span class=o>::</span><span class=n>out</span> <span class=o>&lt;&lt;</span> <span class=n>active</span><span class=o>::</span><span class=n>getMessage</span><span class=p>();</span>
</code></pre></div> <p>Namespace is designed primarily as a mechanism for preventing naming collisions.</p> <p>In applications, namespaces can be used to separate application-specific code from code that might be reusable later (e.g. math functions). When writing a library or code that you want to distribute to others, always place your code inside a namespace.</p> <p>The <code>using</code> declaration can also be used to allow using an unqualified name (with no scope) as an alias for a qualified name. i.e.</p> <div class=highlight><pre><span></span><code><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>

<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Hello&quot;</span><span class=p>;</span> <span class=c1>// no qualified scope resolution is needed anymore</span>
</code></pre></div> <p>An <strong>unnamed namespace</strong> (aka anonymous namespace) is a namespace that is defined without a name, which is treated as if it is part of the parent namespace.</p> <p>It is typically used when you have a lot of content that you want to ensure stays local to a given file. unnamed namespace does this and saves you the trouble to mark all declarations <code>static</code>.</p> <p>An <strong>inline namespace</strong> is one typically used to version content. Its content is also treated as if it is part of the parent namespace. Its advantage is that it preserves the function of existing programs while allowing newer programs to take advantage of newer/better variations by referencing with the newer namespace scope. i.e.</p> <div class=highlight><pre><span></span><code><span class=kr>inline</span> <span class=k>namespace</span> <span class=n>v1</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// body</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=k>namespace</span> <span class=n>v2</span> <span class=p>{</span>
    <span class=kt>void</span> <span class=nf>doSomething</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// body</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=kt>int</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>doSomething</span><span class=p>();</span> <span class=c1>// calls v1 version</span>
    <span class=n>v1</span><span class=o>::</span><span class=n>doSomething</span><span class=p>();</span> <span class=c1>// calls v1 version</span>
    <span class=n>v2</span><span class=o>::</span><span class=n>doSomething</span><span class=p>();</span> <span class=c1>// calls v2 version</span>
<span class=p>}</span>
</code></pre></div> <p>Now when you decide to make v2 the official version, switch the inline keyword of the two versions.</p> <h4 id=ellipsis>Ellipsis<a class=headerlink href=#ellipsis title="Permanent link">&para;</a></h4> <p>Ellipsis argument allows passing a variable number of parameters to a function. Ellipsis are potentially dangerous because it does not know how many parameters are actually passed, nor does it do type check for the passed data types.</p> <p>Functions that use ellipsis must have at least one non-ellipsis parameter. It is conceptually useful to think of the ellipsis as an array that holds any additional parameters beyond those in the argument_list.</p> <div class=highlight><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;cstdarg&gt;</span><span class=c1> // needed to use ellipsis</span><span class=cp></span>

<span class=kt>int</span> <span class=nf>getSum</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>

    <span class=c1>// We access the ellipsis through a va_list, so let&#39;s declare one</span>
    <span class=n>std</span><span class=o>::</span><span class=kt>va_list</span> <span class=n>list</span><span class=p>;</span>

    <span class=c1>// We initialize the va_list using va_start.</span>
    <span class=n>va_start</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sum</span> <span class=o>+=</span> <span class=n>va_arg</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// auto advances the pointer</span>
    <span class=p>}</span>

    <span class=c1>// cleanup va_list</span>
    <span class=n>va_end</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>In general Ellipsis should be avoided unless there is a compelling reason not to.</p> <h4 id=lambda>Lambda<a class=headerlink href=#lambda title="Permanent link">&para;</a></h4> <p>A <strong>lambda expression</strong>, aka function literal, allows us to define an anonymous function inside another function, and take advantage of the closure from naming conflicts. It is stored in the program as a functor object, which overloads the <code>()</code> operator. It takes the form:</p> <div class=highlight><pre><span></span><code><span class=c1>// captureClause, parameters, and returnType can be omitted if not required</span>
<span class=p>[</span> <span class=n>captureClause</span> <span class=p>]</span> <span class=p>(</span> <span class=n>parameters</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=n>returnType</span> <span class=p>{</span>
    <span class=c1>// statements;</span>
<span class=p>}</span>
</code></pre></div> <p>A lambda can be stored in a variable and passed later. These are valid ways:</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
  <span class=c1>// A regular function pointer. Only works with an empty capture clause.</span>
  <span class=kt>double</span> <span class=p>(</span><span class=o>*</span><span class=n>addNumbers1</span><span class=p>)(</span><span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>){</span>
    <span class=p>[](</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>};</span>

  <span class=c1>// Using std::function. The lambda could have a non-empty capture clause.</span>
  <span class=n>std</span><span class=o>::</span><span class=n>function</span> <span class=n>addNumbers2</span><span class=p>{</span> <span class=c1>// note: pre-C++17, use std::function&lt;double(double, double)&gt; instead</span>
    <span class=p>[](</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>};</span>

  <span class=c1>// Using auto. Stores the lambda with its real type.</span>
  <span class=k>auto</span> <span class=n>addNumbers3</span><span class=p>{</span>
    <span class=p>[](</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>};</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Use auto when initializing variables with lambdas, and std::function if you cant initialize the variable with the lambda.</p> <p>Since C++14 it is allowed to use auto for lambda parameters to define generic lambdas. A unique lambda will be <strong>generated</strong> for each different type that auto resolves to.</p> <p>The <strong>capture clause</strong> is used to (indirectly) give a lambda access to variables available in the surrounding scope that it normally would not have access to, by enclosing the variable name (comma-separated) within the <code>[]</code> syntax.</p> <p>The captured variables of a lambda are constant <strong>clones</strong> of the outer scope variables, not the actual variables. The cloned variable can be made <strong>mutable</strong> with the <code>mutable</code> keyword added after the parameter list. Captured variables are members of the lambda object, their values are persisted across multiple calls to the lambda.</p> <p>Passing mutable lambdas can be dangerous as the passed lambda can be copies of its functor. To pass it as a reference, wrap it with <code>std::ref()</code> function which yields a <code>std::reference_wrapper</code> type to ensure the lambda does not make copies while being passed to another function.</p> <p>You can also capture variables by reference (prepending <code>&amp;</code>) to allow it affect the value of the variable within lambda calls. There is a chance for leaving dangling references in lambda so ensure captured variables outlive the lambda.</p> <p><strong>Default capture</strong> can be used to capture all variables mentioned in the lambda. To capture by value, pass in <code>=</code>; to capture by reference, pass in <code>&amp;</code>. Default captures can be mixed with normal captures to capture some variables by value and some by reference, default capture operator must be the first in the list.</p> <p>You can define new variable from captured variables in the capture brackets using initialization braces. But it is best to do it outside and capture it.</p> <h4 id=function-pointers>Function pointers<a class=headerlink href=#function-pointers title="Permanent link">&para;</a></h4> <p>C++ implicitly converts a function into a <strong>function pointer</strong> as needed. Functions used as arguments to another function are sometimes called <strong>callback functions</strong>.</p> <p>Function pointers can be initialized like so <code>int (*fcnPtr)(int){ &amp;foo };</code> which makes fcnPtr points to function foo that has return type of int and takes one int parameter. It can also be initialized with <code>nullptr</code> value. Calling with function pointer is like so <code>(*fcnPtr)(10);</code> or <code>fcnPtr(10);</code>.</p> <p>Make the function pointer type shorter with type alias: <code>using FooFunction = int(*)(int);</code>, or use <code>auto</code> type deduction.</p> <p>Alternatively, use <code>std::function</code> from <code>&lt;functional&gt;</code>, <code>std::function&lt;int(int)&gt; fcn</code> to declare a std::function object.</p> <h4 id=global-variables>Global variables<a class=headerlink href=#global-variables title="Permanent link">&para;</a></h4> <p>Global variables are usually declared at the top of a file, below the includes, and have identifiers prefixed with <code>g_</code> to help easily differentiate from local variables.</p> <p>Global variables are created when the program starts, and destroyed when it ends. They are also known as static variables. Non-constant global variables should be avoided.</p> <p>Global variables by default are visible from other files. You can limit non-constant global variable's visibility internal within a file (called <strong>internal linkage</strong>), by using the <code>static</code> keyword, which is a storage class specifier, see also <code>extern</code> and <code>mutable</code>. Internal objects (and functions) that are defined in different files are considered to be <strong>independent</strong> entities.</p> <p>To use an external global variable defined in another file, you must do forward declaration of that variable, i.e. <code>extern int &lt;var_name&gt;;</code>. However, <code>constexpr</code> variables has no effect with <code>extern</code> keyword, as its type requires the value to be determined at compile time, so <code>constexpr</code> can only be limited to file internal use.</p> <div class=highlight><pre><span></span><code><span class=c1>// External global variable definitions:</span>
<span class=kt>int</span> <span class=n>g_x</span><span class=p>;</span>                       <span class=c1>// non-initialized external global variable</span>
<span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>     <span class=c1>// initialized const external global variable</span>
<span class=k>extern</span> <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_x</span><span class=p>{</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// initialized constexpr external global variable</span>

<span class=c1>// Forward declarations</span>
<span class=k>extern</span> <span class=kt>int</span> <span class=n>g_y</span><span class=p>;</span>                <span class=c1>// forward declaration for non-constant global variable</span>
<span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>g_y</span><span class=p>;</span>          <span class=c1>// forward declaration for const global variable</span>
<span class=k>extern</span> <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>g_y</span><span class=p>;</span>      <span class=c1>// not allowed: constexpr variables can&#39;t be forward declared</span>
</code></pre></div> <p>By default:</p> <ul> <li>functions have external linkage</li> <li>non-constant global variables have external linkage</li> <li>constant global variables have internal linkage</li> </ul> <p><strong>inline variable</strong> is another way to avoid the same variables being copied into multiple files with includes. The linker ensures there is only one copy of each inlined variable that is shared by all files. You must ensure the inline definitions are the same across multiple places where it is defined (which is rare). You can define these variables in header files.</p> <p>Rule of thumb:</p> <ul> <li>avoid creating and using non-constant global variables, they can be changed by anything anywhere, making the program state unpredictable</li> <li>declare local variables as close to where they are used as possible</li> <li>pay attention to the order that global variables are initialized to make sure no variable is referenced before being initialized.<ul> <li>avoid dynamic initialization of variables</li> </ul> </li> <li>better not to directly use a global variable within a function body, pass it as <strong>argument</strong> instead.</li> <li>define your shared global constants in one source file, namespaced, and use <code>extern</code> to expose them to be accessed from other files. Then define its companion header file, with namespaced forward declarations of these constants<ul> <li>this way constants are instantiated only once and you don't have to recompile other source files if only changing the constants values.</li> <li>trade off: the constants are not considered available at compile-time, which we lose some optimization from compiler, and need to worry about variable initialization order</li> </ul> </li> <li>prefer defining inline constexpr global variables in a header file</li> </ul> <h4 id=static-local-variable>static local variable<a class=headerlink href=#static-local-variable title="Permanent link">&para;</a></h4> <p>The <code>static</code> keyword on local variable changes its duration from automatic duration to static duration, which retain its value after it goes out of scope, and retain its previous value when it is back in scope.</p> <p>It's common to use "s_" to prefix static local variables.</p> <p>Do initialize static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.</p> <p>Static local variables can be made const, when creating or initializing an object is expensive. Avoid static local variables unless the variable never needs to be reset.</p> <h4 id=header-files>Header files<a class=headerlink href=#header-files title="Permanent link">&para;</a></h4> <p>A header file contains declarations of functions and variables, which can be <code>#include</code>ed by other source files to pull in declarations.</p> <p>When including a stadnard library header, only the declarations are pulled in for successfuly compilation. During Linking, the standard library gets linked and the definitions are pulled in.</p> <p>A header file is typically paired with a source file of the same base name. The source file should include its paired header file.</p> <p>Use double quotes to include header files that you've written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you've installed elsewhere on your system.</p> <p>A header file may <code>#include</code> other header files. To maximize the chance that missing includes will be flagged by compiler, order your #includes as follows:</p> <ul> <li>The paired header file</li> <li>Other headers from your project</li> <li>3rd party library headers</li> <li>Standard library headers</li> </ul> <p>Header file rule of thumbs:</p> <ul> <li>always include header guards</li> <li>no definitions except global constants</li> <li>header files should group declarations for a specific job, no more</li> <li>every header should compile on its own and not rely on other headers to pull in required dependency</li> </ul> <h3 id=conditionals>Conditionals<a class=headerlink href=#conditionals title="Permanent link">&para;</a></h3> <p>Typical <strong>if</strong> statements:</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>condition</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// body</span>
<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>condition</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// body</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=c1>// body</span>
<span class=p>}</span>
</code></pre></div> <p><strong>switch</strong> statements, note the variable only allow integral/enumerated types:</p> <div class=highlight><pre><span></span><code><span class=k>switch</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>variable</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>case</span> <span class=o>&lt;</span><span class=n>val_1</span><span class=o>&gt;:</span>
        <span class=c1>// body</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=k>case</span> <span class=o>&lt;</span><span class=n>val_1</span><span class=o>&gt;:</span>
        <span class=c1>// body</span>
        <span class=p>[[</span><span class=n>fallthrough</span><span class=p>]];</span> <span class=c1>// special attribute to indicate fallthrough is expected, supress warning</span>
    <span class=k>case</span> <span class=o>&lt;</span><span class=n>val_1</span><span class=o>&gt;:</span> <span class=p>{</span> <span class=c1>// a case can define a block to limit variable scope and supress compile error, in case need to declare and initialize a variable</span>
        <span class=c1>// body</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>default</span><span class=o>:</span>
        <span class=c1>//body</span>
        <span class=k>break</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>A <strong>goto</strong> statement is used with its goto <strong>label</strong> to specify which line to jump to. The label must be used within the function where it is defined. However, it is best to avoid using the goto statments, except for some nested loops.</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>utility</span><span class=p>()</span> <span class=p>{</span>
<span class=nl>repeat</span><span class=p>:</span>
    <span class=c1>// do something</span>
<span class=nl>repeat_2</span><span class=p>:</span>
    <span class=c1>// do something else</span>
    <span class=k>if</span> <span class=p>(...)</span>
        <span class=k>goto</span> <span class=n>repeat</span><span class=p>;</span> <span class=c1>// jump to after the repeat label</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(...)</span>
        <span class=k>goto</span> <span class=n>repeat_2</span><span class=p>;</span> <span class=c1>// jump to after the repeat_2 label</span>
<span class=p>}</span>
</code></pre></div> <p>The shorthand of if statement exists <code>&lt;condition&gt; ? &lt;true_body&gt; : &lt;false_body&gt;</code>, which can be seen as an expression.</p> <p><strong>loops</strong> statments, favor normal while or for loop over do-while loop:</p> <div class=highlight><pre><span></span><code><span class=k>while</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>condition</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// body</span>
<span class=p>}</span>

<span class=k>do</span> <span class=p>{</span>
    <span class=c1>// executes at least once</span>
<span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>condition</span><span class=o>&gt;</span><span class=p>);</span>

<span class=k>for</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>init</span><span class=o>&gt;</span><span class=p>;</span> <span class=o>&lt;</span><span class=n>condition</span><span class=o>&gt;</span><span class=p>;</span> <span class=o>&lt;</span><span class=n>step</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// body</span>
<span class=p>}</span>

<span class=k>for</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>variable</span><span class=o>&gt;</span> <span class=o>:</span> <span class=o>&lt;</span><span class=n>array</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// element will be a copy of the current array element</span>
<span class=p>}</span>
<span class=k>for</span> <span class=p>(</span><span class=o>&lt;</span><span class=n>type</span><span class=o>&gt;&amp;</span> <span class=o>&lt;</span><span class=n>variable</span><span class=o>&gt;</span> <span class=o>:</span> <span class=o>&lt;</span><span class=n>array</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// reference avoids copying array element</span>
<span class=p>}</span>
</code></pre></div> <p>Use <code>continue</code> and <code>break</code> in loops when it simplifies the logic.</p> <h2 id=reference-types>Reference types<a class=headerlink href=#reference-types title="Permanent link">&para;</a></h2> <p>Prior to C++11, there were only two possible value categories: <code>lvalue</code> and <code>rvalue</code>. In C++11, three additional value categories (<code>glvalue, prvalue, and xvalue</code>) were added to support a new feature called <code>move semantics</code>.</p> <h3 id=lvalue-and-rvalue>lvalue and rvalue<a class=headerlink href=#lvalue-and-rvalue title="Permanent link">&para;</a></h3> <p><strong>lvalue</strong> is an expression that evaluates to a function or object that has an <strong>identity</strong> (identifier such as variable or function name, or identifiable memory address). Identifiable objects persist beyond the scope of the expression.</p> <p>It also has two subtypes: modifiable and non-modifiable lvalue</p> <p><strong>rvalue</strong> is an expression that is not an lvalue. Commonly non-string literals and return by value of functions or operators, and only exist within the scope of the expression where they are used.</p> <p>lvalues can implicitly convert to rvalues, so an lvalue can be used wherever an rvalue is required.</p> <p><strong>Dangling reference</strong> can be created when an object being referenced is destroyed before a reference to it is destroyed. Accessing a dangling reference leads to <strong>undefined</strong> behavior.</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>x</span><span class=p>{</span> <span class=mi>5</span> <span class=p>};</span> <span class=c1>// 5 is an rvalue expression</span>
    <span class=k>const</span> <span class=kt>double</span> <span class=n>d</span><span class=p>{</span> <span class=mf>1.2</span> <span class=p>};</span> <span class=c1>// 1.2 is an rvalue expression</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// x is a modifiable lvalue expression</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// d is a non-modifiable lvalue expression</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>return5</span><span class=p>();</span> <span class=c1>// return5() is an rvalue expression (since the result is returned by value)</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// x + 1 is a rvalue</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// the result of static casting d to an int is an rvalue</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=references>References<a class=headerlink href=#references title="Permanent link">&para;</a></h3> <p>An <strong>lvalue reference</strong> acts as an alias for an existing <strong>modifiable lvalue</strong>.</p> <p>Use <code>&amp;</code> to declare an lvalue reference type; the type of the reference must match the type of the referent. i.e. <code>int&amp; ref { x ];</code> where ref is an lvalue reference to the non-reference variable x. You can use a reference to modify the value of the variable/object being referenced.</p> <p>References are not objects.</p> <p>When creating reference to a constant variable, the reference must be declared with <code>const</code> so it can be used to access but not to modify the referent. Favor const lvalue references when possible.</p> <p>When a const lvalue reference is bound to a temporary object (rvalue), the lifetime of the temporary object is extended to match the lifetime of the reference.</p> <p>To <strong>pass by reference</strong>, declare a function parameter as a reference type. When the function is called, lvalue reference parameter is bound to the argument passed in. Binding a reference is always inexpensive, and no copy of variable needs to be made.</p> <p>Passing values by non-const reference allows functions modify the value of arguments passed in, and can only accept modifiable lvalue arguments.</p> <p>Generally, prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy.</p> <p>Common types that are cheap to copy include all of the fundamental types, enumerated types, and std::string_view. Common types that are expensive to copy include std::array, std::string, std::vector, and std::ostream.</p> <p>Note that type deduction using <code>auto</code> drops the <code>const</code> qualifier and the reference.</p> <h3 id=pointers>Pointers<a class=headerlink href=#pointers title="Permanent link">&para;</a></h3> <p>Variable memory addresses aren't exposed, but use the <strong>address-of</strong> operator <code>&amp;</code> can access the memory address of the operand. i.e. <code>&amp;x</code> gets variable x's mem address.</p> <p>The <strong>dereference operator</strong> <code>*</code> returns the value at a given memory address as an <strong>lvalue</strong>. i.e. <code>*ref</code> gets you the lvalue reference from the memory address ref.</p> <p>A <strong>pointer</strong> is an object that holds a memory address as its value. Pointer types are declared using an asterisk (*). i.e. <code>int* ptr;</code>. Always initialize your pointers.</p> <p>Pointers behave much like lvalue references. Some main differences between the two:</p> <ul> <li>References must be initialized, pointers are not required to (but should be)</li> <li>References are not objects, pointers are</li> <li>References can not be reseated, pointers can</li> <li>References must always point at an object, pointers can point to nothing</li> <li>References are safe from dangling references, pointers are not</li> </ul> <p><strong>Favor references over pointers whenever possible</strong>.</p> <p>A <strong>dangling pointers</strong> is a pointer that is holding the address of an object that is no longer valid.</p> <p>A <strong>null pointer</strong> can be initialized with empty initializer or the <code>nullptr</code> keyword. Always verify non-null pointer before dereferencing it. Further, pointers implicitly convert to Boolean values, with null pointer a value of false. It is also acceptable to use <code>assert(ptr);</code>.</p> <p>However, there is NO convenient way to determine whether a non-null pointer is pointing to a valid object or dangling (pointing to an invalid object). Thus, ensure that any pointer that is not pointing at a valid object is set to <code>nullptr</code>.</p> <p>A <strong>pointer to a <code>const</code> value</strong> is a non-const pointer that points to a constant value. i.e. <code>const int* ptr { &amp;x };</code> given x is a const int.</p> <p>A <strong>const pointer</strong> is a pointer whose address cannot be changed after initialization. i.e. <code>int* const ptr { &amp;x };</code></p> <p>Now it is possible to combine the two to have a const pointer to a const value.</p> <p>Three ways to pass data to functions:</p> <div class=highlight><pre><span></span><code><span class=k>using</span> <span class=n>string</span> <span class=o>=</span> <span class=nl>std</span><span class=p>:</span><span class=n>string</span><span class=p>;</span>
<span class=kt>void</span> <span class=nf>passByValue</span><span class=p>(</span><span class=n>string</span> <span class=n>val</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>passByReference</span><span class=p>(</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>passByAddress</span><span class=p>(</span><span class=n>string</span><span class=o>*</span> <span class=n>val</span><span class=p>);</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>string</span> <span class=n>str</span><span class=p>{</span> <span class=s>&quot;Hello&quot;</span> <span class=p>};</span>
    <span class=n>passByValue</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
    <span class=n>passByReference</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
    <span class=n>passByAddress</span><span class=p>(</span><span class=o>&amp;</span><span class=n>str</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <h3 id=return-references>Return references<a class=headerlink href=#return-references title="Permanent link">&para;</a></h3> <p>It is allowed to <strong>return by reference or by address</strong>.</p> <p>Objects returned by reference must live beyond the scope of the function returning the reference, or a dangling reference will result.</p> <p>Never return a local variable by reference. Avoid returning references to non-const local static variables.</p> <p>Prefer return by reference over return by address unless the ability to return no object (using <code>nullptr</code>) is important.</p> <h3 id=memory-allocation>Memory allocation<a class=headerlink href=#memory-allocation title="Permanent link">&para;</a></h3> <p><strong>Static</strong> memory allocation happens for static and global variables which is allocated once at program start and persists throughout program life time.</p> <p><strong>Automatic</strong> memory allocation happens for function parameters and local variables which is allocated when the relevant block is entered, and freed when the block is exited.</p> <p><strong>Dynamic</strong> memory allocation allows requesting <strong>heap memory</strong> from the os when needed, using the <code>new</code> operator. i.e. <code>int* ptr{ new int { 6 } };</code></p> <p>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends. <strong>Memory leaks</strong> happen when your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system.</p> <p>The memory bing dynamically allocated to variable can be freed up when not needed, through the <code>delete &lt;ptr&gt;;</code> operator. Deleting a null pointer has no effect. Do delete the pointer before reassigning it a new value.</p> <p>Avoid having multiple pointers point at the same piece of dynamic memory. When deleting a pointer, set it to <strong>nullptr</strong> if it is not going out of scope immediately.</p> <h2 id=program-defined-types>Program-defined types<a class=headerlink href=#program-defined-types title="Permanent link">&para;</a></h2> <p>Consider Enums, Structs, Classes as program-defined types to distinguish from standard C++ defined types.</p> <p>Whenever you create a new program-defined type, name it starting with a capital letter.</p> <p>A program-defined type used in only one code file should be defined in that code file as close to the first point of use as possible.</p> <p>A program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then <code>#include</code> into each code file as needed.</p> <h3 id=enumerations>Enumerations<a class=headerlink href=#enumerations title="Permanent link">&para;</a></h3> <p>An <strong>enumeration</strong> (<code>enum</code>) is a compound data type where every possible value is defined as a symbolic constant. Enumerated types are considered part of the integer family of types. You can <code>static_cast</code> integers to a defined enumerator.</p> <div class=highlight><pre><span></span><code><span class=k>enum</span> <span class=nc>Color</span> <span class=p>{</span>
    <span class=n>color_red</span><span class=p>,</span>
    <span class=n>color_green</span><span class=p>,</span>
    <span class=n>color_blue</span><span class=p>,</span>
<span class=p>};</span>
</code></pre></div> <p>An enumeration or enumerated type is the program-defined type itself. An enumerator is a symbolic constant that is a possible value for a given enumeration.</p> <p>Name your enumerated types starting with a capital letter. Name your enumerators starting with a lower case letter. Avoid assigning explicit values to your enumerators unless you have a compelling reason to do so.</p> <p><strong>Unscoped enumerations</strong> are named such because they put their enumerator names into the same scope as the enumeration definition itself. If an unscoped enum is defined in the global scope, it pollutes the global scope and significantly raises the chance of naming collisions.</p> <p>One common way to reduce chances of naming collision is to prefix each enumerator with the name of the enumeration itself. A better way is to put the enumerated type definition in a namespace. It is also common to put enumerated types related to a class inside the scope region of the class.</p> <p><strong>Scoped enumeration</strong> are strongly typed (no implicit integer convertion) and strongly scoped (enumerators scoped within the enumeration region). </p> <div class=highlight><pre><span></span><code><span class=k>enum</span> <span class=k>class</span> <span class=nc>Color</span> <span class=p>{</span>
    <span class=n>red</span><span class=p>,</span>
    <span class=n>green</span><span class=p>,</span>
    <span class=n>blue</span><span class=p>,</span>
<span class=p>};</span>
</code></pre></div> <p>Enumerators must be accessed with prefixing the enumeration type. i.e. <code>Color c { Color::blue };</code>. <code>static_cast</code> can still be used to cast enumerators into integers. It is acceptable to use <strong>operator overloading</strong> to reduce the typing in conversions of scoped enumerators.</p> <h3 id=structs>Structs<a class=headerlink href=#structs title="Permanent link">&para;</a></h3> <p>A <code>struct</code> allows bundling multiple variables together into a single type. The variables that are part of the struct are called data <strong>members</strong> (or member variables).</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>Employee</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>id</span> <span class=p>{};</span>
    <span class=kt>int</span> <span class=n>age</span> <span class=p>{};</span>
    <span class=kt>double</span> <span class=n>wage</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span> <span class=c1>// explicit default value</span>
<span class=p>};</span>
</code></pre></div> <p>To access a specific member variable, use the <strong>member selection operator</strong> <code>.</code> on normal variables or references of structs. For pointers, use the <strong>pointer/arrow operator</strong> <code>-&gt;</code> which does an implicit dereference of the pointer object before selecting the member.</p> <p>An <strong>aggregate</strong> data type is any type that can contain multiple data members. <code>structs</code> with only data members are aggregates.</p> <p>Aggregates use a form of initialization called <strong>aggregate initialization</strong> which is just a list of comma-separated initialization values. Each member in the struct is initialized in the order of declaration.</p> <p>When adding a new member to an aggregate, it's safest to add it to the bottom of the definition list so the initializers for other members don't shift.</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>Employee</span> <span class=n>frank</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mf>60000.0</span> <span class=p>};</span> <span class=c1>// copy-list initialization</span>
    <span class=n>Employee</span> <span class=n>robert</span> <span class=p>(</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mf>62500.0</span> <span class=p>);</span>  <span class=c1>// direct initialization (C++20)</span>
    <span class=n>Employee</span> <span class=n>joe</span> <span class=p>{</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>28</span><span class=p>,</span> <span class=mf>45000.0</span> <span class=p>};</span>     <span class=c1>// list initialization</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Variables of a struct type can be const and must be initialized. Structs are generally passed by (const) reference to functions to avoid making copies.</p> <h3 id=classes>Classes<a class=headerlink href=#classes title="Permanent link">&para;</a></h3> <p>By convention, class names should begin with an upper-case letter. The class name effectively acts like a namespace for the nested type.</p> <p>Type alias members make code easier to maintain and can reduce typing. Generally, nested types should only be used when the nested type is used exclusively within that class.</p> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>DateClass</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
    <span class=c1>// private members</span>
    <span class=kt>int</span> <span class=n>m_year</span> <span class=p>{};</span> <span class=c1>// m_ prefix helps distinguish from local variables</span>
    <span class=kt>int</span> <span class=n>m_month</span> <span class=p>{};</span>
    <span class=kt>int</span> <span class=n>m_day</span> <span class=p>{};</span>
<span class=k>public</span><span class=o>:</span>
    <span class=c1>// public members</span>
    <span class=c1>// constructor</span>
    <span class=n>DateClass</span> <span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span> <span class=c1>// tells compiler to create a default constructor</span>
    <span class=n>DateClass</span> <span class=p>()</span> <span class=o>:</span> <span class=n>m_year</span><span class=p>{</span> <span class=mi>1999</span> <span class=p>},</span> <span class=n>m_month</span><span class=p>{</span> <span class=mi>1</span> <span class=p>},</span> <span class=n>m_day</span><span class=p>{</span> <span class=mi>1</span> <span class=p>}</span> <span class=p>{</span> <span class=c1>// member initializer list</span>
    <span class=p>}</span>
    <span class=n>DateClass</span> <span class=p>(</span><span class=kt>int</span> <span class=n>year</span><span class=p>,</span> <span class=kt>int</span> <span class=n>month</span><span class=p>,</span> <span class=kt>int</span> <span class=n>day</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>m_year</span> <span class=o>=</span> <span class=n>year</span><span class=p>;</span>
        <span class=n>m_month</span> <span class=o>=</span> <span class=n>month</span><span class=p>;</span>
        <span class=n>m_day</span> <span class=o>=</span> <span class=n>day</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>DateClass</span> <span class=p>(</span><span class=kt>int</span> <span class=n>year</span><span class=p>,</span> <span class=kt>int</span> <span class=n>month</span><span class=p>,</span> <span class=kt>int</span> <span class=n>day</span><span class=p>)</span> <span class=c1>// preferred, same form with initializer which can also initialize const variables</span>
        <span class=o>:</span> <span class=n>m_year</span><span class=p>{</span> <span class=n>year</span> <span class=p>},</span> <span class=n>m_month</span><span class=p>{</span> <span class=n>month</span> <span class=p>},</span> <span class=n>m_day</span><span class=p>{</span> <span class=n>day</span> <span class=p>}</span> <span class=p>{</span>

    <span class=p>}</span>
<span class=k>protected</span><span class=o>:</span>
    <span class=c1>// protected members</span>
<span class=p>};</span>
</code></pre></div> <p>When not specify any access specifiers, members are private by default. Member functions can be defined inside or outside of a class.</p> <p>When all members variables of a class (or struct) are public, we can use aggregate initialization to initialize the class (or struct) directly using list-initialization. Otherwise specify a constructor.</p> <p>Initialize variables in the initializer list in the same order in which they are declared in your class.</p> <p>Delegating constructors allows calling another constructor from one constructor. It is aka constructor chaining. To do so, put the other constructor call inside the initilization list, not in the body of the constructor.</p> <p>A class exposes the <strong><code>this</code> pointer</strong> to its active instance to refer to its own object for accessing member variables and functions. It can also be reassigned to overwrite the implicit object. Like so: <code>*this = Foo(); // Foo is the constructor</code>. It can also be returned by functions to allow chaining calls.</p> <p>Destructors are like default constructors but has its name preceded by a <code>~</code>. Only one destructor per is class allowed. Destructors are called automatically when the object is destroyed.</p> <p>Note that if you use the <code>exit()</code> function, your program will terminate and no destructors will be called. Be wary if youre relying on your destructors to do necessary cleanup work.</p> <h4 id=class-templates>Class templates<a class=headerlink href=#class-templates title="Permanent link">&para;</a></h4> <h2 id=std-libraries>STD Libraries<a class=headerlink href=#std-libraries title="Permanent link">&para;</a></h2> <h3 id=algorithm><code>&lt;algorithm&gt;</code><a class=headerlink href=#algorithm title="Permanent link">&para;</a></h3> <p>Includes functions like sort, fill, find, binary_search, reverse, shuffle, min/max, count_if.</p> <p><code>std::find(start_iterator, end_iterator, target)</code> searches for the first occurrence of a value in a container. <code>std::find_if</code> works similarly but allows passing in a callable object (function pointer or lambda) that checks to see if a match is found.</p> <p><code>std::count, std::count_if</code> works similarly and count all occurrences of element or elements fulfilling the condition.</p> <p><code>std::sort</code> sorts an array to ascending with an optional custom comparing function.</p> <p><code>std::for_each</code> applies a custom function to every element in an array, which is an alternative to writing a loop. It can also be parallelized for faster processing.</p> <p>Favor using functions from the algorithms library over writing your own functionality to do the same thing.</p> <h3 id=iostream><code>&lt;iostream&gt;</code><a class=headerlink href=#iostream title="Permanent link">&para;</a></h3> <p><code>std::cout</code>, allows print text to program STDOUT. Similarily for <code>std::cerr</code> for print text to STDERR. Put a line break and flushes output with <code>std::endl</code>. Prefer to use <code>\n</code> for adding line breaks to avoid high frequency in flush.</p> <p>Use insertion operator <code>&lt;&lt;</code> along with <code>cout/cerr/endl</code>, or extraction operator <code>&gt;&gt;</code> for <code>cin</code>.</p> <p>There is also <code>std::getline</code> for reading a full ine of text into a variable. i.e. <code>std::getline(std::cin &gt;&gt; std::ws, input);</code> The <code>std::ws</code> is a type of input manipulator to tell std::in ignore leading whitespace, which is necessary to continuously read user inputs in an interactive program.</p> <p>When doing extraction with <code>std::cin</code>, an extraction of user input can fail for many reasons, common one is the input causes an overflow, which leave <code>cin</code> in a failed state and cause any future extraction to be skipped.</p> <p>What to do in this case where bad user input can be anticipated is to use <code>std::cin.fail()</code> to check if the extraction failed, then <code>std::cin.clear()</code> to reset the failure flag and something like <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code> to skip what user entered (before hitting the enter key), any probably ask the user to enter again and tell them why it failed.</p> <h3 id=iterator><code>&lt;iterator&gt;</code><a class=headerlink href=#iterator title="Permanent link">&para;</a></h3> <p>Contains functions like <code>begin, end</code> on arrays.</p> <h3 id=random><code>&lt;random&gt;</code><a class=headerlink href=#random title="Permanent link">&para;</a></h3> <p>Provides PRNG (Pseudo Random Number Generator) function that generates fairly evenly distributed random numbers.</p> <p><code>std::mt19937</code> is a 32-bit Mersenne Twister random number generator function; <code>std::mt19937_64</code> is the 64-bit version.</p> <p>Also to make sure it is truely random everytime the program is run, seed the PRNG with system clock (<code>&lt;chrono&gt;</code> is needed).</p> <p>Use <code>std::uniform_int_distribution&lt;&gt; die{ 1, 6 };</code> to limit the random number range. Like so:</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>rand_gen</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>mt19937</span> <span class=n>mt</span><span class=p>{</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span>
        <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>steady_clock</span><span class=o>::</span><span class=n>now</span><span class=p>().</span><span class=n>time_since_epoch</span><span class=p>().</span><span class=n>count</span><span class=p>()</span>
        <span class=p>)</span> <span class=p>};</span>
    <span class=c1>// alternatively seed with the os implemented random_device</span>
    <span class=n>std</span><span class=o>::</span><span class=n>mt19937</span> <span class=n>mt</span><span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>random_device</span><span class=p>{}()</span> <span class=p>};</span>

    <span class=n>std</span><span class=o>::</span><span class=n>uniform_int_distribution</span><span class=o>&lt;&gt;</span> <span class=n>die6</span><span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>6</span> <span class=p>};</span>

    <span class=kt>int</span> <span class=n>rand</span> <span class=o>=</span> <span class=n>die6</span><span class=p>(</span><span class=n>mt</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>rand</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Make a singleton of PRNG, and only seed a PRNG once, and use it throughout your program. Do so with a namespace and define a global PRNG, like so:</p> <div class=highlight><pre><span></span><code><span class=k>namespace</span> <span class=n>Random</span> <span class=p>{</span> <span class=c1>// capital R to avoid conflicts with functions named random()</span>
    <span class=n>std</span><span class=o>::</span><span class=n>mt19937</span> <span class=n>mt</span><span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>random_device</span><span class=p>{}()</span> <span class=p>};</span>

    <span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>min</span><span class=p>,</span> <span class=kt>int</span> <span class=n>max</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>std</span><span class=o>::</span><span class=n>uniform_int_distribution</span> <span class=n>die</span><span class=p>{</span> <span class=n>min</span><span class=p>,</span> <span class=n>max</span> <span class=p>};</span> 
        <span class=k>return</span> <span class=n>die</span><span class=p>(</span><span class=n>mt</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=utility><code>&lt;utility&gt;</code><a class=headerlink href=#utility title="Permanent link">&para;</a></h3> <p>Provides useful types like Pairs, generic swap function</p> <h3 id=cassert><code>&lt;cassert&gt;</code><a class=headerlink href=#cassert title="Permanent link">&para;</a></h3> <p>An assertion tests if an expression evaluates to true. If not, the program terminates with an error message. This is useful to do precondition check anywhere fits.</p> <p>It is best to use this format <code>assert(&lt;condition&gt; &amp;&amp; "error message");</code> so when this condition expression is false, the informative message is also printed.</p> <p>Generally use assertions to document cases that should be logically impossible; for other cases use proper exception handling methods. Asserts should never be encountered in production code. Asserts should be used only in cases where corruption isn't likely to occur if the program terminates unexpectedly.</p> <p>If the macro <code>NDEBUG</code> is defined, the assert macro gets disabled.</p> <p><code>static_assert(&lt;condition&gt;, "diagnostic_message");</code> to evaluate something at compile time.</p> <h3 id=cstdint><code>&lt;cstdint&gt;</code><a class=headerlink href=#cstdint title="Permanent link">&para;</a></h3> <p>For defining fixed-width integers.</p> <h3 id=cstdlib><code>&lt;cstdlib&gt;</code><a class=headerlink href=#cstdlib title="Permanent link">&para;</a></h3> <p>Halt functions:</p> <p><code>std::exit()</code> can be used to explicitly exit the program.</p> <p>Do note that it does not clean up any local variables (either in the current function, or in functions up the call stack). Avoid using it unless you know how to properly clean up your program.</p> <p><code>std::atexit()</code> can be used to pass in a cleanup function when <code>exit()</code> is called.</p> <p>In a multi-threaded program, it is better to use <code>std::quick_exit()</code> to exit the program (which does not immediately clean up static objects that may still be accessed by other threads), paired with <code>std::at_quick_exit()</code> for cleanup.</p> <p>Furthermore, <code>std::abort()</code> function causes your program to terminate abnormally. There is also <code>std::terminate()</code> which is typically used in conjunction with exceptions. Both does not do propery cleanups. Generally use exceptions for error handling.</p> <h3 id=cmath><code>&lt;cmath&gt;</code><a class=headerlink href=#cmath title="Permanent link">&para;</a></h3> <p>Handy math functions. i.e. <code>pow, abs, max, min</code></p> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../../Java/Java_Std_Lib_Cheatsheet/ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Java Std Lib Cheatsheet </div> </div> </a> <a href=../../Perl/Perl-Lang-Specs/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Perl Language Reference </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.53cc9318.min.js></script> <script src=../../../assets/javascripts/bundle.e9c9f54f.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs', 'navigation.instant'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> </body> </html>